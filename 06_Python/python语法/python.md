#

# 并发

## 基本概念

### 进程的三种状态

![](../../image/进程三种状态转换图.png)

```python
# 程序开始运行之后，并不是立即开始执行代码，而是会进入就绪状态，等待操作系统调度
import time
# 开始运行
print('程序开始运行')

name = input('>>>')     # 程序进入阻塞，等待用户进行输入
# 用户输入后，进入就绪状态，等待调度
print(name)             # 运行

time.sleep(1)           # 阻塞

print('程序运行结束')    # 运行
# 运行结束
```

### 进程，线程，协程

1. 进程   
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行**资源**分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
2. 线程   
线程是进程的一个实体,是**CPU调度和分派**的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
3. 协程   
协程是一种**用户态的轻量级线程**，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，**可以不加锁的访问全局变量**，所以上下文的切换非常快。

### 多进程和多线程

|对比维度|多进程|多线程|总结|
|---|---|---|---|
|数据共享、同步|数据共享复杂，需要用IPC；数据是分开的，同步简单|因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂|各有优势|
|内存、CPU|占用内存多，切换复杂，CPU利用率低|占用内存少，切换简单，CPU利用率高|线程占优|
|创建销毁、切换|创建销毁、切换复杂，速度慢|创建销毁、切换简单，速度很快|线程占优|
|编程、调试|编程简单，调试简单|编程复杂，调试复杂|进程占优|
|可靠性|进程间不会互相影响|一个线程挂掉将导致整个进程挂掉|进程占优|
|分布式|适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单|适应于多核分布式|进程占优|

### 线程和协程

协程:又被称为用户级线程或绿色线程。

1. 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。
2. 线程进程都是同步机制，而协程则是异步
3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态

### 事件驱动

在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？

> 方式一：创建一个线程，该线程一直循环检测是否有鼠标点击，那么这个方式有以下几个缺点：

1. CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？
2. 如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；
3. 如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；

> 方式二：事件驱动模型

1. 有一个事件（消息）队列；
2. 鼠标按下时，往这个队列中增加一个点击事件（消息）；
3. 有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；
4. 事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；

![](../../image/事件驱动.png)

事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。

让我们用例子来比较和对比一下单线程、多线程以及事件驱动编程模型。下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I/O操作时阻塞自身。阻塞在I/O操作上所花费的时间已经用灰色框标示出来了

![](../../image/单线程、多线程以及事件驱动比对.png)

当我们面对如下的环境时，事件驱动模型通常是一个好的选择：

1. 程序中有许多任务，而且任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且在等待事件到来时，某些任务会阻塞。
2. 当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。

总结：异步IO涉及到了事件驱动模型，进程中维护一个**消息队列**，当客户端又请求时，就会把请求添加到消息队列中，线程从消息队列中**轮询取要处理的请求**，遇到I/O阻塞时（操作系统处理调用I/O接口处理，与程序无关），则进行上下文切换，处理其他请求，当I/O操作完成时，调用回调函数，告诉线程处理完成，然后再切换回来，处理完成后返回给客户端

## 技术点关键词

### GIL,线程锁

python中存在GIL这个“线程锁”，关键地方可以使用c语言解决GIL问题 然后可以提高cpu占用效率

### 守护进程

主进程创建守护进程

1. 守护进程会在主进程代码执行结束后就终止
2. 守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children

> [!NOTE]
> 进程之间是互相独立的，主进程代码运行结束，守护进程随即终止

```python
#主进程代码运行完毕,守护进程就会结束
from multiprocessing import Process
from threading import Thread
import time
def foo():
    print(123)
    time.sleep(1)
    print("end123")

def bar():
    print(456)
    time.sleep(3)
    print("end456")


p1=Process(target=foo)
p2=Process(target=bar)

p1.daemon=True
p1.start()
p2.start()
print("main-------") #打印该行则主进程代码结束,则守护进程p1应该被终止,可能会有p1任务执行的打印信息123,因为主进程打印main----时,p1也执行了,但是随即被终止
```

### 互斥锁(mutex)

为了方式上面情况的发生，就出现了互斥锁(Lock)

```python
import threading
import time
 
 
def run(n):
    lock.acquire()  #获取锁
    global num
    num += 1
    lock.release()  #释放锁
 
lock = threading.Lock()     #实例化一个锁对象
 
num = 0
t_obj = []  
 
for i in range(20000):
    t = threading.Thread(target=run, args=("t-%s" % i,))
    t.start()
    t_obj.append(t)
 
for t in t_obj:
    t.join()
 
print(f"num:{num}")
```

### RLock递归锁

### 队列

Queue是多进程的安全队列，可以使用Queue实现多进程之间的数据传递。

`Queue.qsize()`：      返回当前队列包含的消息数量；   
`Queue.empty()`：      如果队列为空，返回True，反之False ；   
`Queue.full()`：       如果队列满了，返回True,反之False；   
`Queue.get()`:         获取队列中的一条消息，然后将其从列队中移除，可传参超时时长。   
`Queue.get_nowait()`： 相当Queue.get(False),取不到值时触发异常：Empty；   
`Queue.put()`:         将一个值添加进数列，可传参超时时长。   
`Queue.put_nowait()`:  相当于Queue.get(False),当队列满了时报错：Full。   

```python
from multiprocessing import Process, Queue
import time

def write(q):
   for i in ['A', 'B', 'C', 'D', 'E']:
      print('Put %s to queue' % i)
      q.put(i)
      time.sleep(0.5)

def read(q):
   while True:
      v = q.get(True)
      print('get %s from queue' % v)

if __name__ == '__main__':
   q = Queue()
   pw = Process(target=write, args=(q,))
   pr = Process(target=read, args=(q,))
   print('write process = ', pw)
   print('read  process = ', pr)
   pw.start()
   pr.start()
   pw.join()
   pr.join()
   pr.terminate()
   pw.terminate()
```

## 其他问题